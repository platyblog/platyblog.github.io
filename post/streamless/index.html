<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta name="generator" content="Hugo 0.25-DEV" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>De la finitude de l&#39;être | Platyblog</title>
    <meta name="description" content="A small, interesting constructivist problem">
    <meta name="keywords" content="math, ">
    
    
    
    
    

  <meta name="author" content="Yannick">


    <meta property="og:title" content="De la finitude de l&#39;être" />
<meta property="og:description" content="A small, interesting constructivist problem" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://platyblog.github.io/post/streamless/" />



<meta property="article:published_time" content="2017-07-02T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2017-07-02T00:00:00&#43;00:00"/>

<meta property="og:site_name" content="Platyblog" />










    




    <meta name="theme-color" content="#000">

    
    
    
    <link rel="canonical" href="http://platyblog.github.io/post/streamless/">
    
    
    <link rel="icon" sizes="any" href="data:image/svg+xml,%3Csvg%20viewBox='0%200%2046%2045'%20xmlns='http://www.w3.org/2000/svg'%3E%3Ctitle%3EAfter%20Dark%3C/title%3E%3Cpath%20d='M.708%2045L23%20.416%2045.292%2045H.708zM35%2038L23%2019%2011%2038h24z'%20fill='%23000'/%3E%3C/svg%3E">

      <style>
       html{font-size:12px}*{box-sizing:border-box;text-rendering:geometricPrecision}body{font-size:1rem;line-height:1.5rem;margin:0;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,serif;word-wrap:break-word}h1,h2,h3,h4,h5,h6{line-height:1.3em}fieldset{border:none;padding:0;margin:0}pre{padding:2rem;margin:1.75rem 0;background-color:#fff;border:1px solid #ccc;overflow:auto}code[class*=language-],pre[class*=language-],pre code{font-weight:100;text-shadow:none;margin:1.75rem 0}a{cursor:pointer;color:#ff2e88;text-decoration:none;border-bottom:1px solid #ff2e88}a:hover{background-color:#ff2e88;color:#fff}.grid{display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}.grid.\-top{-ms-flex-align:start;-ms-grid-row-align:flex-start;align-items:flex-start}.grid.\-middle{-ms-flex-align:center;-ms-grid-row-align:center;align-items:center}.grid.\-bottom{-ms-flex-align:end;-ms-grid-row-align:flex-end;align-items:flex-end}.grid.\-stretch{-ms-flex-align:stretch;-ms-grid-row-align:stretch;align-items:stretch}.grid.\-baseline{-ms-flex-align:baseline;-ms-grid-row-align:baseline;align-items:baseline}.grid.\-left{-ms-flex-pack:start;justify-content:flex-start}.grid.\-center{-ms-flex-pack:center;justify-content:center}.grid.\-right{-ms-flex-pack:end;justify-content:flex-end}.grid.\-between{-ms-flex-pack:justify;justify-content:space-between}.grid.\-around{-ms-flex-pack:distribute;justify-content:space-around}.cell{-ms-flex:1;flex:1;box-sizing:border-box}@media screen and (min-width:768px){.cell.\-1of12{-ms-flex:0 0 8.33333%;flex:0 0 8.33333%}.cell.\-2of12{-ms-flex:0 0 16.66667%;flex:0 0 16.66667%}.cell.\-3of12{-ms-flex:0 0 25%;flex:0 0 25%}.cell.\-4of12{-ms-flex:0 0 33.33333%;flex:0 0 33.33333%}.cell.\-5of12{-ms-flex:0 0 41.66667%;flex:0 0 41.66667%}.cell.\-6of12{-ms-flex:0 0 50%;flex:0 0 50%}.cell.\-7of12{-ms-flex:0 0 58.33333%;flex:0 0 58.33333%}.cell.\-8of12{-ms-flex:0 0 66.66667%;flex:0 0 66.66667%}.cell.\-9of12{-ms-flex:0 0 75%;flex:0 0 75%}.cell.\-10of12{-ms-flex:0 0 83.33333%;flex:0 0 83.33333%}.cell.\-11of12{-ms-flex:0 0 91.66667%;flex:0 0 91.66667%}}@media screen and (max-width:768px){.grid{-ms-flex-direction:column;flex-direction:column}.cell{-ms-flex:0 0 auto;flex:0 0 auto}}.hack,.hack blockquote,.hack code,.hack em,.hack h1,.hack h2,.hack h3,.hack h4,.hack h5,.hack h6,.hack strong{font-size:1rem;font-style:normal;font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,serif}.hack blockquote,.hack code,.hack em,.hack strong{line-height:20px}.hack blockquote,.hack code,.hack footer,.hack h1,.hack h2,.hack h3,.hack h4,.hack h5,.hack h6,.hack header,.hack li,.hack ol,.hack p,.hack section,.hack ul{float:none;margin:0;padding:0}.hack blockquote,.hack h1,.hack ol,.hack p,.hack ul{margin-top:20px;margin-bottom:20px}.hack h1{position:relative;display:inline-block;display:table-cell;padding:20px 0 30px;margin:0;overflow:hidden}.hack h1:after{content:"====================================================================================================";position:absolute;bottom:10px;left:0}.hack h1+*{margin-top:0}.hack h2,.hack h3,.hack h4,.hack h5,.hack h6{position:relative;margin-bottom:1.75rem}.hack h2:before,.hack h3:before,.hack h4:before,.hack h5:before,.hack h6:before{display:inline}.hack h2:before{content:"## "}.hack h3:before{content:"### "}.hack h4:before{content:"#### "}.hack h5:before{content:"##### "}.hack h6:before{content:"###### "}.hack li{position:relative;display:block;padding-left:20px}.hack li:after{position:absolute;top:0;left:0}.hack ul>li:after{content:"-"}.hack ol{counter-reset:a}.hack ol>li:after{content:counter(a) ".";counter-increment:a}.hack blockquote{position:relative;padding-left:17px;padding-left:2ch;overflow:hidden}.hack blockquote:after{content:">\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>\A>";white-space:pre;position:absolute;top:0;left:0;line-height:20px}.hack em:after,.hack em:before{content:"*";display:inline}.hack pre code:after,.hack pre code:before{content:''}.hack code{font-weight:700}.hack code:after,.hack code:before{content:"`";display:inline}.hack hr{position:relative;height:20px;overflow:hidden;border:0;margin:20px 0}.hack hr:after{content:"----------------------------------------------------------------------------------------------------";position:absolute;top:0;left:0;line-height:20px;width:100%;word-wrap:break-word}@-moz-document url-prefix(){.hack h1{display:block}}.hack-ones ol>li:after{content:"1."}p{margin:0 0 1.75rem}.container{max-width:70rem}.container,.container-fluid{margin:0 auto;padding:0 1rem}.inner{padding:1rem}.inner2x{padding:2rem}.pull-left{float:left}.pull-right{float:right}.progress-bar{height:8px;opacity:.8;background-color:#ccc;margin-top:12px}.progress-bar.progress-bar-show-percent{margin-top:38px}.progress-bar-filled{background-color:gray;height:100%;transition:width .3s ease;position:relative;width:0}.progress-bar-filled:before{content:'';border:6px solid transparent;border-top-color:gray;position:absolute;top:-12px;right:-6px}.progress-bar-filled:after{color:gray;content:attr(data-filled);display:block;font-size:12px;white-space:nowrap;position:absolute;border:6px solid transparent;top:-38px;right:0;-ms-transform:translateX(50%);transform:translateX(50%)}table{width:100%;border-collapse:collapse;margin:1.75rem 0;color:#778087}table td,table th{vertical-align:top;border:1px solid #ccc;line-height:15px;padding:10px}table thead th{font-size:10px}table tbody td:first-child{font-weight:700;color:#333}.form{width:30rem}.form-group{margin-bottom:1.75rem;overflow:auto}.form-group label{border-bottom:2px solid #ccc;color:#333;width:10rem;display:inline-block;height:38px;line-height:38px;padding:0;float:left;position:relative}.form-group.form-success label{color:#4caf50!important;border-color:#4caf50!important}.form-group.form-warning label{color:#ff9800!important;border-color:#ff9800!important}.form-group.form-error label{color:#f44336!important;border-color:#f44336!important}.form-control{outline:none;border:none;border-bottom:2px solid #ccc;padding:.5rem 0;width:20rem;height:38px;background-color:transparent}.form-control:focus{border-color:#555}.form-group.form-textarea label:after{position:absolute;content:'';width:2px;background-color:#fff;right:-2px;top:0;bottom:0}textarea.form-control{height:auto;resize:none;padding:1rem 0;border-bottom:2px solid #ccc;border-left:2px solid #ccc;padding:.5rem}select.form-control{border-radius:0;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none}.help-block{color:#999;margin-top:.5rem}.form-actions{margin-bottom:1.75rem}.btn{display:-ms-inline-flexbox;display:inline-flex;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;cursor:pointer;outline:none;padding:.65rem 2rem;font-size:1rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;z-index:1}.btn:active{box-shadow:inset 0 1px 3px rgba(0,0,0,.12)}.btn.btn-ghost{border-color:#757575;color:#757575;background-color:transparent}.btn.btn-ghost:focus,.btn.btn-ghost:hover{border-color:#424242;color:#424242;z-index:2}.btn.btn-ghost:hover{background-color:transparent}.btn-block{width:100%;display:-ms-flexbox;display:flex}.btn-default{color:#fff;background-color:#e0e0e0;border:1px solid #e0e0e0;color:#333}.btn-default:focus:not(.btn-ghost),.btn-default:hover{background-color:#dcdcdc;border-color:#dcdcdc}.btn-success{color:#fff;background-color:#4caf50;border:1px solid #4caf50}.btn-success:focus:not(.btn-ghost),.btn-success:hover{background-color:#43a047;border-color:#43a047}.btn-success.btn-ghost{border-color:#4caf50;color:#4caf50}.btn-success.btn-ghost:focus,.btn-success.btn-ghost:hover{border-color:#388e3c;color:#388e3c;z-index:2}.btn-error{color:#fff;background-color:#f44336;border:1px solid #f44336}.btn-error:focus:not(.btn-ghost),.btn-error:hover{background-color:#e53935;border-color:#e53935}.btn-error.btn-ghost{border-color:#f44336;color:#f44336}.btn-error.btn-ghost:focus,.btn-error.btn-ghost:hover{border-color:#d32f2f;color:#d32f2f;z-index:2}.btn-warning{color:#fff;background-color:#ff9800;border:1px solid #ff9800}.btn-warning:focus:not(.btn-ghost),.btn-warning:hover{background-color:#fb8c00;border-color:#fb8c00}.btn-warning.btn-ghost{border-color:#ff9800;color:#ff9800}.btn-warning.btn-ghost:focus,.btn-warning.btn-ghost:hover{border-color:#f57c00;color:#f57c00;z-index:2}.btn-info{color:#fff;background-color:#00bcd4;border:1px solid #00bcd4}.btn-info:focus:not(.btn-ghost),.btn-info:hover{background-color:#00acc1;border-color:#00acc1}.btn-info.btn-ghost{border-color:#00bcd4;color:#00bcd4}.btn-info.btn-ghost:focus,.btn-info.btn-ghost:hover{border-color:#0097a7;color:#0097a7;z-index:2}.btn-primary{color:#fff;background-color:#2196f3;border:1px solid #2196f3}.btn-primary:focus:not(.btn-ghost),.btn-primary:hover{background-color:#1e88e5;border-color:#1e88e5}.btn-primary.btn-ghost{border-color:#2196f3;color:#2196f3}.btn-primary.btn-ghost:focus,.btn-primary.btn-ghost:hover{border-color:#1976d2;color:#1976d2;z-index:2}.btn-group{overflow:auto}.btn-group .btn{float:left}.btn-group .btn-ghost:not(:first-child){margin-left:-1px}.card{border:1px solid #ccc}.card .card-header{color:#333;text-align:center;background-color:#ddd;padding:.5rem 0}.alert{color:#ccc;padding:1rem;border:1px solid #ccc;margin-bottom:1.75rem}.alert-success{color:#4caf50;border-color:#4caf50}.alert-error{color:#f44336;border-color:#f44336}.alert-info{color:#00bcd4;border-color:#00bcd4}.alert-warning{color:#ff9800;border-color:#ff9800}.media:not(:last-child){margin-bottom:1.25rem}.media-left{padding-right:1rem}.media-left,.media-right{display:table-cell;vertical-align:top}.media-right{padding-left:1rem}.media-body{display:table-cell;vertical-align:top}.media-heading{font-size:1.16667rem;font-weight:700}.media-content{margin-top:.3rem}.avatarholder,.placeholder{background-color:#f0f0f0;text-align:center;color:#b9b9b9;font-size:1rem;border:1px solid #f0f0f0}.avatarholder{width:48px;height:48px;line-height:46px;font-size:2rem;background-size:cover;background-position:50%;background-repeat:no-repeat}.avatarholder.rounded{border-radius:33px}.loading{height:20px;width:20px;animation:a .6s infinite linear;border:2px solid #e91e63;border-right-color:transparent;border-radius:50%}.btn .loading{display:inline-block;float:left;margin-right:.5rem;width:14px;height:14px}@keyframes a{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.menu{width:100%}.menu .menu-item{display:block;color:#616161;border-color:#616161}.menu .menu-item.active,.menu .menu-item:hover{color:#000;border-color:#000;background-color:transparent}@media screen and (max-width:768px){.form-group label{display:block;border-bottom:none;width:100%}.form-group.form-textarea label:after{display:none}.form-control{width:100%}textarea.form-control{border-left:none;padding:.5rem 0}pre::-webkit-scrollbar{height:3px}}@media screen and (max-width:480px){.form{width:100%}}
.dark{color:#ccc}.dark,.dark pre{background-color:#000}.dark pre{padding:0;border:none}.dark pre code{color:#00bcd4}.dark h1 a,.dark h2 a,.dark h3 a,.dark h4 a,.dark h5 a{color:#ccc}.dark code,.dark strong{color:#fff}.dark code{font-weight:100}.dark table{color:#ccc}.dark table td,.dark table th{border-color:#444}.dark table tbody td:first-child{color:#fff}.dark .form-group label{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .form-group.form-textarea label:after{background-color:#000}.dark .form-control{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .form-control:focus{border-color:#ccc;color:#ccc}.dark textarea.form-control{color:#ccc}.dark .card{border-color:rgba(95,95,95,.78)}.dark .card .card-header{background-color:transparent;color:#ccc;border-bottom:1px solid rgba(95,95,95,.78)}.dark .btn.btn-ghost.btn-default{border-color:#ababab;color:#ababab}.dark .btn.btn-ghost.btn-default:focus,.dark .btn.btn-ghost.btn-default:hover{border-color:#9c9c9c;color:#9c9c9c;z-index:1}.dark .btn.btn-ghost.btn-default:focus,.dark .btn.btn-ghost.btn-default:hover{border-color:#e0e0e0;color:#e0e0e0}.dark .btn.btn-ghost.btn-primary:focus,.dark .btn.btn-ghost.btn-primary:hover{border-color:#64b5f6;color:#64b5f6}.dark .btn.btn-ghost.btn-success:focus,.dark .btn.btn-ghost.btn-success:hover{border-color:#81c784;color:#81c784}.dark .btn.btn-ghost.btn-info:focus,.dark .btn.btn-ghost.btn-info:hover{border-color:#4dd0e1;color:#4dd0e1}.dark .btn.btn-ghost.btn-error:focus,.dark .btn.btn-ghost.btn-error:hover{border-color:#e57373;color:#e57373}.dark .btn.btn-ghost.btn-warning:focus,.dark .btn.btn-ghost.btn-warning:hover{border-color:#ffb74d;color:#ffb74d}.dark .avatarholder,.dark .placeholder{background-color:transparent;border-color:#333}.dark .menu .menu-item{color:#ccc;border-color:rgba(95,95,95,.78)}.dark .menu .menu-item.active,.dark .menu .menu-item:hover{color:#fff;border-color:#ccc}

       @keyframes intro {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
.muted {
  color: rgba(255, 255, 255, 0.5);
}
iframe {
  border: 0;
}
main, footer {
  animation: intro 0.3s both;
  animation-delay: 0.15s;
}
:target {
  color: #fff;
}
/* hack.css overrides and enhancements */
.hack li ul {
  margin: 0;
}
.main {
  padding: 20px 10px;
}
nav a.active {
  background-color: #ff2e88;
  color: #fff;
}
a[itemprop="url"] {
  color: #ff9800;
}
a[itemprop="url"]:hover {
  color: #fff;
}
a[href*="://"]::after {
  /* data uri svg icon. thanks to @Fastidious for the idea */
  content: " " url("data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20class='i-external'%20viewBox='0%200%2032%2032'%20width='14'%20height='14'%20fill='none'%20stroke='%23ff9800'%20stroke-linecap='round'%20stroke-linejoin='round'%20stroke-width='9.38%'%3E%3Cpath%20d='M14%209%20L3%209%203%2029%2023%2029%2023%2018%20M18%204%20L28%204%2028%2014%20M28%204%20L14%2018'/%3E%3C/svg%3E");
}
html {
  font-size: 13px;
}
.hack pre {
  font-size: 17px;
}
article [itemprop="description"] {
  margin-bottom: 20px;
  margin-top: 20px;
}
@media screen and (min-width: 768px) {
  html {
    font-size: 1em;
  }
  .container {
    max-width: 50rem;
  }
}

       

      </style>
      
      
      <script type="text/javascript">
       window.MathJax = {
           tex2jax: {
               inlineMath: [ ['$','$'], ["\\(","\\)"] ],
               processEscapes: true
           }
       };
      </script>
      <link rel="stylesheet" href="//jmblog.github.io/color-themes-for-highlightjs/css/themes/hemisu-dark.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/coq.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  
  <body class="hack dark main container">
    <header>
  
  <nav itemscope itemtype="http://schema.org/SiteNavigationElement">
    
    
      <a itemprop="url" class="active" href="/post/"><span itemprop="name">Posts</span></a>
    
      <a itemprop="url" class="" href="/"><span itemprop="name">Home</span></a>
    
  </nav>


</header>
    <main>
  <article itemscope itemtype="http://schema.org/BlogPosting">
    
<meta itemprop="name" content="De la finitude de l&#39;être">
<meta itemprop="description" content="A small, interesting constructivist problem">


<meta itemprop="dateModified" content="2017-07-02T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="2093">



<meta itemprop="keywords" content="" />

    <header>
      <h1 itemprop="headline">De la finitude de l&#39;être</h1>
      <p class="muted">
        <svg style="margin-bottom:-3px" class="i-clock" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
  <circle cx="16" cy="16" r="14" />
  <path d="M16 8 L16 16 20 20" />
</svg>
<span>10 minute read</span>
<svg style="margin-bottom: -3px" class="i-edit" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
  <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z" />
</svg>

  Published: <time datetime="2017-07-02T00:00:00&#43;00:00">2 Jul, 2017</time>


      </p>
    </header>
    
      <blockquote itemprop="description">A small, interesting constructivist problem</blockquote>
    
    

    <div itemprop="articleBody">
      <p>A reddit user, /u/INL_TT, has recently proposed a few problems to be solved using your favourite proof assistant. The last one has been particularly interesting:<a href="https://coq-math-problems.github.io/Problem5/">coq-math-problems</a>.</p>

<p>The problem is taken from a paper by Coquand and Spiwack<sup class="footnote-ref" id="fnref:1"><a rel="footnote" href="#fn:1">1</a></sup> investigating ways to formalise in a constructivist context the notion of finite set. A common caracterisation of a finite set A is the impossibility to inject the natural numbers into A. Or phrased differently, any stream of elements of A contains a duplicate. Formally, naming this caracterisation streamless:</p>

<pre><code class="language-Coq">Definition streamless (X : Set) := forall f : nat -&gt; X,
  {i : nat &amp; {j : nat &amp; i &lt;&gt; j /\ f i = f j}}.
</code></pre>

<p>The problem is simply to show that the streamless property is stable under sum.</p>

<pre><code class="language-Coq">Theorem streamless_sum : forall X Y, 
    streamless X -&gt; streamless Y -&gt; streamless (X + Y).
</code></pre>

<p>Let us first understand why the problem is non-trivial.
Let $f: \mathbb N \rightarrow X + Y$. Classically, we obviously know that the stream $f$ contains either an infinity of elements of $X$ or an infinity of elements of $Y$, maybe of both. By extracting the corresponding substream, we should be able to conclude.</p>

<p>However one cannot in general decide which of $X$ or $Y$ to chose: we therefore are seemingly unable to build neither a stream of $X$ nor a stream of $Y$, rendering our hypotheses useless.</p>

<p>One could therefore ponder whether our definition of finite set can be reduced to one allowing us to only manipulate a list of values, rather than a stream. Indeed, a finite set $A$ is intuitively characterised by a finite cardinal, i.e. we can find a list of values containing any element of $A$. It however turns out that this alternative definition is strictly stronger, the streamless caracterisation does not allow us to compute the cardinal of our set.</p>

<p>It feels like we cannot extract a stream of one of our types, and it feels like we cannot reduce our definition to a list: I&rsquo;ve been completely stuck! The first assertion of the previous sentence however turns out to be wrong, as David Reboullet found out and shared his proof with us. The proof goes as follows.</p>

<p>Assume that $f 0 = inl x0$. While we indeed cannot directly extract a substream of X, we can create one by filling out the elements of Y by the dummy value we found, $x0$. Let us name $proj_f$ this stream.
Now we can ask our oracle for a collision in $proj_f.$ We obtain two distinct indices $n_1,~n_2$ such that $proj_f(n_1) = proj_f(n_2)$. This may feel useless granted the collision is likely to be two occurrences of $x_0,$ but we actually do get something by looking at these indices in our original stream $f:$
  * Either we find two elements of X: the collision was real, we won!
  * Or we found at least one element of Y: in addition to $x_0$, we have a couple in X * Y, and their indices in $f$.
We therefore are able to build a function get_next which associates to a stream either a pair of elements, or a collision. Formally in Coq, we simply need to duplicate the code to account whether (f 0) is in X or in Y. With sub_stream_l and sub_stream_r are the obvious projections:</p>

<pre><code class="language-Coq">  Context {X Y: Set}.
  Variable finite_X: streamless X.
  Variable finite_Y: streamless Y.

  Program Definition get_next (f: nat -&gt; X + Y):
    {n: nat * nat &amp; {z: X * Y &amp; f (fst n) = inl (fst z) /\
                                f (snd n) = inr (snd z)}} +
    {i : nat &amp; {j : nat &amp; i &lt;&gt; j /\ f i = f j}} := 
    match f 0 with
    | inl x0 =&gt;
      match finite_X (sub_stream_l f x0) with
        existT _ n1 (existT _ n2 (conj ineq collision)) =&gt;
        match (f n1, f n2) with
        | (inl x1, inl x2) =&gt;
          inr (existT _ n1 (existT _ n2 (conj ineq _)))
        | (inr y, _) =&gt; inl (existT _ (0,n1) (existT _ (x0,y) _))
        | (_, inr y) =&gt; inl (existT _ (0,n2) (existT _ (x0,y) _))
        end
      end
    | inr y0 =&gt; 
      match finite_Y (sub_stream_r f y0) with
        existT _ n1 (existT _ n2 (conj ineq collision)) =&gt;
        match (f n1, f n2) with
        | (inr y1, inr y2) =&gt; inr (existT _ n1 (existT _ n2 (conj ineq _)))
        | (inl x, _) =&gt; inl (existT _ (n1,0) (existT _ (x,y0) _))
        | (_, inl x) =&gt; inl (existT _ (n2,0) (existT _ (x,y0) _))
        end
      end
    end.
  Next Obligation.
    clear Heq_anonymous1.
    unfold sub_stream_l in collision; rewrite &lt;- H0, &lt;- H1 in collision.
    rewrite collision; reflexivity.
  Qed.
  Next Obligation.
    clear Heq_anonymous1.
    unfold sub_stream_r in collision; rewrite &lt;- H0, &lt;- H1 in collision.
    rewrite collision; reflexivity.
  Qed.
</code></pre>

<p>The important intuition is that our oracle can therefore be used at any moment to know whether I can still find both an element of X and one of Y in my stream. We can therefore now leverage get_next in order to build a stream of pairs in X * Y, until a collision is found and we propagate this collision for the remaining indices.
By recurrence on the index, we define the following stream g:</p>

<ul>
<li><p>g 0 = get_next f</p></li>

<li><p>g (S n) = inr collision                           when g n = inr collision \ we keep a found collision</p></li>

<li><p>g (S n) = let n1,n2 be the indices of (g n) in</p>

<pre><code>    let k := max(n1,n2) in                                        

    let H := get_next (fun n =&gt; f(n + k)) in                                   \\ we shift f and ask get_next

    if H = inr collision

    then inr collision

    else let n1',n2' be the indices of H in

        n1' + max (n1,n2), n2' + max(n1,n2)
</code></pre></li>
</ul>

<p>More formally, in Coq, we obtain:</p>

<pre><code class="language-Coq">  Lemma helping_arith: forall n m p, n &lt;&gt; m -&gt; n + p &lt;&gt; m + p.
      intros; omega.
  Qed.

  Fixpoint lift_get_next (f: nat -&gt; X + Y) n:
    {n: nat * nat &amp; {z: X * Y &amp; f (fst n) = inl (fst z) /\
                                f (snd n) = inr (snd z)}} +
    {i : nat &amp; {j : nat &amp; i &lt;&gt; j /\ f i = f j}} :=
    match n with
    | 0 =&gt; get_next f 
    | S m =&gt;
      match lift_get_next f m with
      | inl (existT _ (n1,n2) (existT _ _ _)) =&gt;
        match get_next (shift f (S (max n1 n2))) with
        | inl (existT _ (n1',n2') (existT _ (x,y) H)) =&gt;
          inl (existT _ (n1' + S (max n1 n2), n2' + S (max n1 n2)) 
                        (existT _ (x,y) H))
        | inr (existT _ n1' (existT _ n2' (conj ineq eq))) =&gt; 
          inr (existT _ (n1' + S (max n1 n2))
                        (existT _ (n2' + S (max n1 n2))
                         (conj (helping_arith n1' n2' (S (max n1 n2)) ineq) eq)))
        end
      | inr witness =&gt; inr witness
      end
    end.

</code></pre>

<p>We have built this way a new stream which only contains either collisions of the original stream, or elements of the original stream. The key difference with the first one we built is that we tagged X and Y on the same side of the sum. If we are looking say for elements of X, then for any index, we can find an X, or we find a collision.</p>

<p>Asking once again the oracle what it has to say about the projection of (lift_get_next f) over X is enough to conclude. Indeed, once again, we can test the returned indices against the original stream. Two cases are possible:</p>

<ul>
<li>Either both indices correspond to a pair of elements in (lift_get_next f). We have found a collision.</li>
<li>Or at least one of them is not a pair in (lift_get_next f). But then it contains a collision instead.</li>
</ul>

<p>Qed.</p>

<p>Proving it formally, we as usual need to duplicate the code, and reason a bit about (lift_get_next f) to ensure that the indices we obtain are indeed not the same:</p>

<pre><code class="language-Coq">  Lemma lift_get_next_monotone:
    forall f n n1 n2 H1 m1 m2 H2,
      (lift_get_next f n = inl (existT _ (n1,n2) H1)) -&gt;
      (lift_get_next f (S n) = inl (existT _ (m1,m2) H2)) -&gt;
      n1 &lt; m1 /\ n2 &lt; m2.
  Proof.
    intros; cbn in H0.
    rewrite H in H0.
    destruct H1 as ([x1 y1] &amp; eq1 &amp; eq1').
    destruct H2 as ([x2 y2] &amp; eq2 &amp; eq2').
    cbn in *.
    destruct (get_next (shift f (S (max n1 n2)))) eqn:eq;
        [| destruct s as (i &amp; j &amp; ineq &amp; ?); inversion H0].
    destruct s as ([i j] &amp; [x y] &amp; Eq &amp; Eq').
    inversion H0; clear H0.
    subst; cbn in *.
    split; rewrite Nat.add_comm; apply lt_plus_trans; unfold lt; apply le_n_S.
    apply Max.le_max_l.
    apply Max.le_max_r.
  Qed.

  Lemma lift_get_next_monotone_strong:
    forall f d n m (eqd: d = m - n) (lt: n &lt; m) n1 n2 H1 m1 m2 H2,
      (lift_get_next f n = inl (existT _ (n1,n2) H1)) -&gt;
      (lift_get_next f m = inl (existT _ (m1,m2) H2)) -&gt;
      n1 &lt; m1 /\ n2 &lt; m2.
  Proof.
    intros.
    generalize dependent m; revert m1 m2 H2.
    induction d as [| d IH]; intros; [omega |].
    cbn in *.
    destruct d as [| d].
    - clear IH.
      assert (m = S n) by omega; subst m.
      eapply lift_get_next_monotone; eauto. 
    - destruct m as [| m]; [omega |].
      assert (eqd': S d = m - n) by omega; clear eqd.
      generalize H0; intros Hyp; cbn in H0.
      destruct (lift_get_next f m) eqn:eq; [| inversion H0].
      destruct s as ([i j] &amp; [x y] &amp; Eq &amp; Eq').
      destruct (get_next (shift f (S (max i j)))) eqn:eq';
        [| destruct s as (? &amp; ? &amp; ineq &amp; ?); inversion H0].
      destruct s as ([i' j'] &amp; [x' y'] &amp; Eq'' &amp; Eq''').
      inversion H0; clear H0.
      subst; unfold fst, snd in *.
      destruct lift_get_next_monotone with (1 := eq) (2 := Hyp).
      eapply IH in eq; eauto; [| omega]; clear IH; destruct eq as [ineq1 ineq2].
      clear Hyp eq' H.
      split; omega.
  Qed.
      
  Lemma lift_get_next_somewhat_inj:
    forall f n m (ineq: n &lt;&gt; m) n1 n2 H1 m1 m2 H2,
      (lift_get_next f n = inl (existT _ (n1,n2) H1)) -&gt;
      (lift_get_next f m = inl (existT _ (m1,m2) H2)) -&gt;
      n1 &lt;&gt; m1 /\ n2 &lt;&gt; m2.
  Proof.
    intros f n m ineq; intros.
    destruct (lt_eq_lt_dec n m) as [[? | ?] | ?].
    edestruct lift_get_next_monotone_strong; eauto; omega.
    omega.
    edestruct lift_get_next_monotone_strong; eauto; omega.
  Qed.

  (* We project lift_get_next *)
  Definition proj_lift_get_next (f: nat -&gt; X + Y): (nat -&gt; X) + (nat -&gt; Y) :=
    match f 0 with
    | inl x0 =&gt; inl (fun n =&gt;
                      match lift_get_next f n with
                      | inl (existT _ _ (existT _ (x,_) _)) =&gt; x
                      | inr _ =&gt; x0
                      end)
    | inr y0 =&gt; inr (fun n =&gt;
                      match lift_get_next f n with
                      | inl (existT _ _ (existT _ (_,y) _)) =&gt; y
                      | inr _ =&gt; y0
                      end)
    end.                   

  Theorem streamless_sum : streamless (X + Y).
  Proof.
    intros f.
    set (g := proj_lift_get_next f); unfold proj_lift_get_next in g.
    destruct (f 0) as [x0 | y0].
    - destruct g as [h | h] eqn:H; subst g; inversion H; clear H.
      destruct (finite_X h) as (n1 &amp; n2 &amp; ineq &amp; H).
      subst h.
      destruct (lift_get_next f n1) as [([? ?] &amp; [? ?] &amp; [? ?]) | 
                collision] eqn:H1; [| exact collision].
      destruct (lift_get_next f n2) as [([? ?] &amp; [? ?] &amp; [? ?]) | 
                collision] eqn:H2; [| exact collision].
      unfold fst, snd in *; subst.
      exists n, n3; split; [| rewrite e,e1; reflexivity].
      refine (match (lift_get_next_somewhat_inj f n1 n2 ineq n n0 _ n3 n4 _ H1 H2)
              with conj X _ =&gt; X end). 
    - destruct g as [h | h] eqn:H; subst g; inversion H; clear H.
      destruct (finite_Y h) as (n1 &amp; n2 &amp; ineq &amp; H).
      subst h.
      destruct (lift_get_next f n1) as [([? ?] &amp; [? ?] &amp; [? ?]) | collision] eqn:H1; [| exact collision].
      destruct (lift_get_next f n2) as [([? ?] &amp; [? ?] &amp; [? ?]) | collision] eqn:H2; [| exact collision].
      unfold fst, snd in *; subst.
      exists n0, n4; split; [| rewrite e0,e2; reflexivity].
      refine (match (lift_get_next_somewhat_inj f n1 n2 ineq n n0 _ n3 n4 _ H1 H2)
              with conj _ X =&gt; X end). 
  Qed.
</code></pre>

<p>Quite fun how such a simple statement can reveal itself to be quite subtle! Once again, congratulations to David for finding this proof. I did not check it against the one from the paper but would imagine them to match.</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1"><a href="http://assert-false.net/arnaud/papers/Constructively%20Finite.pdf">Constructively finite?</a>
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
</ol>
</div>

    </div>
    
    <footer>
      <hr>
      <p>
  Published
  
    
      by <span itemprop="author">Yannick</span>
    
  
  <time datetime="2017-07-02T00:00:00&#43;00:00">
    2 Jul, 2017
  </time>
  
    in <span itemprop="articleSection"><a href="/categories/math/">math</a></span>
  
  
  using <span itemprop="wordCount">2093</span> words.
</p>

      



    </footer>
  </article>
</main>
    <footer>
  

</footer>
  </body>
</html>
